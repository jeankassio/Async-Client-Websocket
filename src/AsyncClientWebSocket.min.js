/*!
 * Async Client Websocket v1.2.5
 * by Jean Kássio
 *
 * More info:
 * https://jeankassio.dev
 *
 * Copyright Jean Kássio
 * Released under the MIT license
 * https://github.com/jeankassio/Async-Client-Websocket/blob/main/LICENSE
 *
 * @preserve
 */ class WebSocketClient{constructor(e){this.url=e,this.socket=null,this.onOpen=null,this.onClose=null,this.onMessage=null,this.onError=null,this.onSpam=null,this.onVerbose=null,this.onLatency=null,this.autoReconnect=!1,this.reconnectAttemps=0,this.messageQueue=[],this.keepAliveInterval=null,this.recordLatency=!1,this.ping="ping",this.pong="pong",this.verbose=!1,this.spamTime=null,this.lastSendTime=0,this.outgoingMiddleware=null,this.incomingMiddleware=null}connect(e=5e3){return new Promise((t,s)=>{let i=setTimeout(()=>{this._log("Connection Timeout"),s(Error("Connection timeout"))},e);this.socket=new WebSocket(this.url),this.socket.onopen=e=>{for(i&&clearTimeout(i),this.onOpen&&this.onOpen(e),this.queueLocalStorage&&loadQueue();this.messageQueue.length>0;){let s=this.messageQueue.shift();this._log("Sending queue message:",s),this.socket.send(s)}t()},this.socket.onmessage=e=>{let t=e.data;this._log("Received Message:",t),this.incomingMiddleware&&(t=this.incomingMiddleware(t),this._log("Incoming Middleware return:",t)),this.onMessage&&(this.recordLatency&&t===this.pong?(this.latencyTimestamp=Date.now(),this.latency=this.latencyTimestamp-this.lastPingTimestamp,this.onLatency&&this.onLatency(this.latency),this._log("Calculated latency:",this.latency)):this.onMessage(t))},this.socket.onerror=e=>{this.onError&&this.onError(e),this._log("Error found:",e),s()},this.socket.onclose=e=>{this.onClose&&this.onClose(e),this._log("Connection closed"),this._attemptReconnect()}})}send(e){if(this.outgoingMiddleware&&(e=this.outgoingMiddleware(e)),this.socket&&this.socket.readyState===WebSocket.OPEN){if(this.spamTime){let t=Date.now();t-this.lastSendTime>this.spamTime?(this.socket.send(e),this._log("Send message:",e),this.lastSendTime=t):(this.onSpam&&this.onSpam(e),this._log("Message detected has Spam:",e))}else this.socket.send(e),this._log("Send message:",e)}else this.messageQueue.push(e),this.queueLocalStorage&&saveQueue(this.messageQueue),this._log("Websocket is not open! Putting message in queue")}disconnect(){this.socket&&(this.socket.close(),this._log("Websocket disconnected"))}destroy(){this.autoReconnect=!1,this.disconnect(),this.stopKeepAlive(),this.socket=null,this._log("Websocket destroyed")}isConnected(){let e=this.socket&&this.socket.readyState===WebSocket.OPEN;return this._log("isConnected was called, result:",e),e}loadQueue(){let e=localStorage.getItem("wsclient-queue");e&&(this.messageQueue=JSON.parse(e))}saveQueue(e){localStorage.setItem("wsclient-queue",JSON.stringify(this.messageQueue))}saveQueueOnLocalStorage(e){this.queueLocalStorage=e}startKeepAlive(e=15e3,t){t&&(this.ping=t,this._log("Set ping name:",t)),this.keepAliveInterval&&(this._log("KeepAlive is already running, disabling"),clearInterval(this.keepAliveInterval)),this.keepAliveInterval=setInterval(()=>{this._log("Send ping to KeepAlive"),this.isConnected()?(this.send(this.ping),this._log("Ping to KeepAlive sended:",this.ping)):this._log("Websocket is not connected")},e)}stopKeepAlive(){this._log("Stopping KeepAlive"),this.keepAliveInterval?(clearInterval(this.keepAliveInterval),this._log("KeepAlive stopped")):this._log("KeepAlive is not running")}getLatency(){return this.latency}untrackLatency(){this.recordLatency=!1,this._log("Untracking latency"),this.pingInterval?(clearInterval(this.pingInterval),this._log("Track latency stopped")):this._log("Track latency is not running")}trackLatency(e,t,s=1e4){this._log("Starting track latency"),this.recordLatency=!0,this.lastPingTimestamp=Date.now(),e&&(this.ping=e,this._log("Set ping name:",e)),t&&(this.pong=t,this._log("Set pong name:",t)),this.pingInterval=setInterval(()=>{this.lastPingTimestamp=Date.now(),this.send(this.ping),this._log("Send ping to latency:",this.ping)},s)}autoReconnect(e=3e3,t=infinity,s=null){this.autoReconnect=!0,this.reconnectInterval=e,this.maxReconnectAttemps=t,this.reconnectCallback=s,this._log("Auto reconnect activated")}allowSpam(){this.spamTime=null}preventSpam(e=100){this.spamTime=e}log(e=!0){this.verbose=e}setOutgoingMiddleware(e){this.outgoingMiddleware=e}setIncomingMiddleware(e){this.incomingMiddleware=e}_log(...e){this.verbose&&(console.log("[WebSocketClient]",...e),this.onVerbose&&this.onVerbose(...e))}_attemptReconnect(){this.autoReconnect&&!(this.reconnectAttemps>=this.maxReconnectAttemps)&&setTimeout(()=>{this.connect().then(()=>{this._log("Websocket reconnected successfully"),this.reconnectAttemps=0,this.reconnectCallback&&(this.reconnectCallback(),this._log("Reconnect callback was called"))}).catch(()=>{this._log("Error reconnecting Websocket"),this.reconnectAttemps++,this._attemptReconnect()})},this.reconnectInterval)}}
